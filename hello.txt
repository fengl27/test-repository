var canvas = document.getElementById("yourcanvas");
        
        var aspectRatio = 16/9;
        
        var width = Math.min(window.innerWidth, window.innerHeight * aspectRatio);
        var height = width / aspectRatio;
        
        canvas.width = width;
        canvas.height = height;
        
        canvas.style.left = (window.innerWidth - width) / 2 + "px";
        canvas.style.top = (window.innerHeight - height) / 2 + "px";
        
        var ctx = canvas.getContext("2d");
        
        ctx.lineJoin = "round";
        // {
        var colorThing = function(r, g, b) {
            if((!g && g !== 0)) {
                return "rgb(" + r + ", " + r + ", " + r + ")";
            }
            else {
                return "rgb(" + r + ", " + g + ", " + b + ")";
            }
        };
        var doingStroke = true;
        var fill = function(r, g, b) {
            ctx.fillStyle = colorThing(r, g, b);
        };
        var noFill = function() {
        };
        var stroke = function(r, g, b) {
            doingStroke = true;
            ctx.strokeStyle = colorThing(r, g, b);
        };
        var noStroke = function() {
            doingStroke = false;
        };
        var strokeWeight = function(weight) {
            ctx.lineWidth = weight;
        };
        
        var triangle = function(x1, y1, x2, y2, x3, y3) {
            var fillStyle = ctx.fillStyle;
            var path = new Path2D();
            path.moveTo(x1, y1);
            path.lineTo(x2, y2);
            path.lineTo(x3, y3);
            path.closePath();
            ctx.fill(path);
            if(doingStroke) {
                ctx.stroke(path);
            }
        };
        var ellipse = function(x, y, width, height) {
            x = x || 0;
            y = y || 0;
            if(width < 0 && height < 0) {
                return;
            }
            if(width === height) {
                ctx.beginPath();
                ctx.arc(x, y, width / 2, 0, Math.PI * 2);
                ctx.fill();
                if(doingStroke) {
                    ctx.stroke();
                }
            }
            else {
                var w = width / 2, h = height / 2;
                var path = new Path2D();
                path.moveTo(x + w, y);
                for(var deg = 0.05; deg < 2; deg += 0.05) {
                    path.lineTo(x + w * Math.cos(deg * Math.PI), y + h * Math.sin(deg * Math.PI));
                }
                path.closePath();
                ctx.fill(path);
                if(doingStroke) {
                    ctx.stroke(path);
                }
            }
        };
        var arc = function(x, y, width, height, start, stop) {
            if (width <= 0 || stop < start) { return; }
            start *= Math.PI / 180;
            stop *= Math.PI / 180;
            while (start < 0) {
                start += 2 * Math.PI;
                stop += 2 * Math.PI;
            }
            if (stop - start > 2 * Math.PI) {
                ellipse(x, y, width, height);
                return;
            }
            
            var wr = width / 2;
            var hr = height / 2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            for(var dir = start; dir < stop; dir += 0.05) {
                ctx.lineTo(x + Math.cos(dir) * wr, y + Math.sin(dir) * hr);
            }
            ctx.fill();
            if(doingStroke) {
                ctx.beginPath();
                ctx.moveTo(x + Math.cos(start) * wr, y + Math.sin(start) * hr);
                for(var dir = start; dir < stop; dir += 0.05) {
                    ctx.lineTo(x + Math.cos(dir) * wr, y + Math.sin(dir) * hr);
                }
                ctx.stroke();
                var fillStyle = ctx.fillStyle;
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(x + Math.cos(start) * wr, y + Math.sin(start) * hr, ctx.lineWidth / 2, 0, Math.PI * 2);
                ctx.arc(x + Math.cos(stop) * wr, y + Math.sin(stop) * hr, ctx.lineWidth / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = fillStyle;
            }
        };
        var rect = function(x, y, width, height, radius) {
            ctx.beginPath();
            if(radius === 0) {
                ctx.rect(x, y, width, height);
            }
            else {
                ctx.roundRect(x, y, width, height, radius);
            }
            ctx.fill();
            if(doingStroke) {
                ctx.stroke();
            }
        };
        var point = function(x, y) {
            var fillStyle = ctx.fillStyle;
            ctx.fillStyle = ctx.strokeStyle;
            ctx.beginPath();
            ctx.arc(x, y, ctx.lineWidth / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = fillStyle;
        };
        var line = function(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            point(x1, y1);
            point(x2, y2);
        };
        var translate = function(x, y) {
            ctx.translate(x, y);
        };
        var rotate = function(deg) {
            ctx.rotate(deg * Math.PI / 180);
        };
        var scale = function(sx, sy) {
            ctx.scale(sx, sy);
        };
        var transformMatrix = [];
        var resetMatrix = function() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        };
        var pushMatrix = function() {
            transformMatrix.push(ctx.getTransform());
        };
        var popMatrix = function() {
            ctx.setTransform(transformMatrix[transformMatrix.length - 1]);
            transformMatrix.splice(transformMatrix.length - 1, 1);
        };
        // } Defining drawing functions and matrix stuff
        // {
        var sin = function(deg) {
            return Math.sin(deg * Math.PI / 180);
        };
        var cos = function(deg) {
            return Math.cos(deg * Math.PI / 180);
        };
        var PVector = function(x, y) {
            this.x = x || 0;
            this.y = y || 0;
        };
        PVector.get = function(vect) {
            return new PVector(vect.x, vect.y);
        };
        PVector.add = function(v1, v2) {
            return new PVector(v1.x + v2.x, v1.y + v2.y);
        };
        PVector.div = function(vect, num) {
            return new PVector(vect.x / num, vect.y / num);
        };