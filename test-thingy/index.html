<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>pee</title>
        <style>
            body {
                background-color: #5f9b8c;
            }
            #hosting {
                visibility: hidden;
                display: flex;
                width: 100vw;
                height: 100vh;

                align-items: center;
                justify-content: center;

                font-family: Arial, Helvetica, sans-serif;
                font-size: 5em;
                color: #233c4b;

                position: absolute;
                top: 0px;
                left: 0px;
            }

            
            #chat {
                visibility: hidden;
                background-color: #233c4b;
                position: absolute;
                top: 0px;
                bottom: 0px;
                left: 0px;
                right: 0px;
                padding: 10px;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            #chat-messages {
                background-color: #5f9b8c;
                flex: 1;                    /* fills remaining space */
                overflow-y: auto;           /* enable scrolling */

                display: flex;
                flex-direction: column;
                gap: 10px;

                padding: 10px;
                border-radius: 10px;
                
                color: #233c4b;
                font-family: Arial, Helvetica, sans-serif;
            }

            #chat-send {
                background-color: #5f9b8c;
                padding: 10px;
                border-radius: 10px;

                display: flex;
                flex-direction: row;
                gap: 10px;
            }

            #chat-send-message {
                flex: 1;

                border: 2px solid #233c4b;
                border-radius: 5px;

                font-size: 2em;
            }

            button {
                font-family: sans-serif;
                background-color: #a0c382;
                border: 2px solid #233c4b;
                border-radius: 5px;
            }

            button:hover {
                filter: brightness(95%);
            }

            button:active {
                filter: brightness(85%);
            }

            #chat-send-button {
                font-size: 2em;
            }
        </style>
        <style>
            .peer-message, .you-message, .announcement-message {
                padding: 10px;
                font-weight: bold;
            }
            .peer-message {
                background-color: #fac846;
                border-radius: 5px 5px 0px 5px;
                text-align: left;
                width: fit-content;
                margin-left: auto;
            }
            .you-message {
                background-color: #ff7d2d;
                border-radius: 5px 5px 5px 0px;
                text-align: right;
                width: fit-content;
                margin-right: auto;
            }
            .announcement-message {
                background-color: #a0c382;
                border-radius: 5px;
                text-align: center;
            }

            #choices > button, #choices > input {
                font-size: 3em;
                padding: 0.2em;
            }

            .input-button {
                background-color: rgba(255, 255, 255, 0.5);
                color: black;
                width: 50%;
                height: 50vh;
                position: absolute;
                top: 0px;
                left: 0px;
            }
            #thingy-stream {
                position: absolute;
                top: 0px;
                left: 0px;
                width: 100%;
                height: 100vh;
            }
        </style>
    </head>
    <body>
        <div id = "choices">
            <button onclick = 'host()'>Host</button><br>
            <button onclick = 'join()'>Join</button>
            <input type = "number" min = "100000" max = "999999" id = "input-code" placeholder = "join code...">
        </div>
        <div id = "hosting" hidden>
            <h1 id = "hosting-txt">ERROR</h1>
        </div>
        <div id = "chat" hidden>
            <video id = "thingy-stream"></video>
        </div>
    </body>
    <!--Peer.js library (https://peerjs.com/)-->
    <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
    <script>
var currentTouches = [];
var copyTouch = function({identifier, pageX, pageY}) {
    return {identifier, pageX, pageY};
}
var getTouchId = function(target) {
    for(var j = 0; j < currentTouches.length; j ++) {
        if(currentTouches[j].identifier === target) {
            return j;
        }
    }
    return -1;//not found
};
canvas.addEventListener("touchstart", function(e) {
    e.preventDefault();
    var touches = e.changedTouches;
    for(var i = 0; i < touches.length; i ++) {
        currentTouches.push(copyTouch(touches[i]));
        //text(touches[i].identifier, touches[i].pageX, touches[i].pageY);
        handleTouchStart(copyTouch(touches[i]));
    }
});
canvas.addEventListener("touchmove", function(e) {
    e.preventDefault();
    var touches = e.changedTouches;
    for(var i = 0; i < touches.length; i ++) {
        var id = getTouchId(touches[i].identifier);
        //line(currentTouches[id].pageX, currentTouches[id].pageY, touches[i].pageX, touches[i].pageY);
        currentTouches.splice(id, 1, copyTouch(touches[i]));
    }
    
});
canvas.addEventListener("touchend", function(e) {
    e.preventDefault();
    var touches = e.changedTouches;
    for(var i = 0; i < touches.length; i ++) {
        //text(touches[i].identifier, touches[i].pageX, touches[i].pageY);
        var id = getTouchId(touches[i].identifier);
        //line(currentTouches[id].pageX, currentTouches[id].pageY, touches[i].pageX, touches[i].pageY);
        handleTouchEnd(copyTouch(touches[i]));
        currentTouches.splice(id, 1);
    }
});
canvas.addEventListener("touchcancel", function(e) {
    e.preventDefault();
    var touches = e.changedTouches;
    for(var i = 0; i < touches.length; i ++) {
        var id = getTouchId(touches[i].identifier);
        currentTouches.splice(id, 1);
    }
});
var controls = [];

var Button = function(x, y, w, h, hx, hy, hw, hh, pressF, releaseF, shouldHide, texture, pressTexture) {//x, y, width, height, function
    this.fs = [pressF, releaseF];
    this.pos = new PVector(x, y);
    this.size = new PVector(w, h);
    this.actualPos = new PVector(hx, hy);
    this.actualSize = new PVector(hw, hh);
    this.isPressed = false;
    this.lastPressed = false;
    this.shouldHide = shouldHide || false;
    this.texture = texture;
    this.pressTexture = pressTexture;
};
Button.prototype.display = function() {
    if(!this.shouldHide) {
        if(this.texture) {
            if(this.isPressed) {
                ctx.drawImage(this.pressTexture, this.pos.x, this.pos.y, this.size.x, this.size.y);
            }
            else {
                ctx.drawImage(this.texture, this.pos.x, this.pos.y, this.size.x, this.size.y);
            }
        }
        else {
            if(this.isPressed) {
                fill(48, 48, 48);
            }
            else {
                fill(100, 100, 100);
            }
            rect(this.pos.x, this.pos.y, this.size.x, this.size.y);
        }
    }
};
Button.prototype.initialize = function() {
    if(this.lastPressed && !this.isPressed) {
        this.fs[1]();//you just released it
    }
    this.lastPressed = this.isPressed;
    this.isPressed = false;
};
Button.prototype.update = function(pos) {
    if(pos.x > this.actualPos.x && pos.x < this.actualPos.x + this.actualSize.x && pos.y > this.actualPos.y && pos.y < this.actualPos.y + this.actualSize.y) {
        if(!this.isPressed) {
            this.fs[0]();
        }
        this.isPressed = true;
    }
};

var buttons = [
    new Button(canvas.width / 10, canvas.height * 6/8, canvas.height / 8, canvas.height / 8, 0, 0, canvas.width / 10 + canvas.height / 8, canvas.height, function() {
        controls[0] = true;
    }, function() {
        controls[0] = false;
    }, false, document.getElementById("left"), document.getElementById("left-pressed")),
    new Button(canvas.width / 10 + canvas.height / 8 + 5, canvas.height * 6/8, canvas.height / 8, canvas.height / 8, canvas.width / 10 + canvas.height / 8, 0, canvas.width / 2 - canvas.width / 10 - canvas.height / 8, canvas.height, function() {
        controls[1] = true;
    }, function() {
        controls[1] = false;
    }, false, document.getElementById("right"), document.getElementById("right-pressed")),
    new Button(0, 0, 0, 0, canvas.width /2, 0, canvas.width / 2, canvas.height, function() {
        controls[2] = true;
    }, function() {
        controls[2] = false;
    }, true),
];

var doMobile = function() {
    for(var i = 0; i < buttons.length; i ++) {
        buttons[i].initialize();
    }
    for(var i = 0; i < currentTouches.length; i ++) {
        var pos = new PVector(currentTouches[i].pageX, currentTouches[i].pageY);
        for(var j = 0; j < buttons.length; j ++) {
            buttons[j].update(pos);
        }
    }
};
var displayMobile = function() {
    for(var i = 0; i < buttons.length; i ++) {
        buttons[i].display();
    }
};
    </script>
    <script>
        // GET is the default method, so we don't need to set it
        async function getHello() {
            try {
                const response = await fetch('/hello');
                const text = await response.text();
                console.log('GET response text:');
                console.log(text); // Print the greeting as text
            } catch (err) {
                console.error('Error fetching /hello:', err);
            }
        }

        async function postHello(data) {
            try {
                const response = await fetch('/hello', {
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    method: 'POST',
                    body: JSON.stringify(data)
                });
                /*
                const text = await response.text();

                console.log('POST response:');
                console.log(text); // Should be 'OK'
                */
            } catch (err) {
                console.error('Error posting to /hello:', err);
            }
        }

    </script>
    <script>
var handleTouchStart = function() {};
var handleTouchEnd   = function() {};
const choiceDiv = document.getElementById("choices");
const hostDiv = document.getElementById("hosting");
const chatDiv = document.getElementById("chat");
const hostIdEl = document.getElementById("hosting-txt");
const codeInput = document.getElementById("input-code");

var videoEl = document.getElementById("thingy-stream");

const id = 100000 + Math.floor(900000 * Math.random());//your id
var peer = new Peer(id);
var conn;

function createMessage(side, txt) {
    var thing = document.createElement("div");
    thing.textContent = txt;
    thing.classList.add(side);
    return thing;
}

function handleData(data) {
    if(data === "connected") {
        //hosting, connected
        hostIdEl.textContent = "CONNECTED";
        return;
    }
    //this is a message

    console.log("I AM POSTING THE HELLO of " + data.txt);
    postHello({x: data.x * window.screen.width, y: data.y * window.screen.height});
}
function handleClose() {
    console.log("lolllll get dumped on");
}
function sendMessage(x, y, type) {
    conn.send({x:x, y:y, type:type});//type is whether it's mouse down or mouse up
}
function host() {
    console.log("ID " + id);
    console.log("peer: ", peer);

    choiceDiv.hidden = true;
    hostDiv.style.visibility = "visible";
    hostIdEl.textContent = id;

    peer.on('connection', function(connection) {
        console.log(connection.peer + " iddidiidididi");
        conn = connection;
        conn.on('data', handleData);

        navigator.mediaDevices.getDisplayMedia({
            video: true
        }).then(stream => {
            console.log("sending stream of doom");
            var call = peer.call(connection.peer, stream);//one-sided call of doom
        });
    });
}
function join() {
    conn = peer.connect(codeInput.value);
    // on open will be launch when you successfully connect to PeerServer
    console.log("hello, probably");

    conn.on('open', function(){
        // here you have conn.id
        console.log("IT TOTALLY WORKS!!!!");
        conn.send('connected');
        chatDiv.style.visibility = "visible";
        choiceDiv.hidden = true;

        //call jank of doom
        peer.on('call', (call) => {
            call.answer(); 

            // Listen for the incoming stream from the calling peer
            call.on('stream', (remoteStream) => {
                // Display the remote stream in a video element
                console.log(remoteStream.constructor.name);
                videoEl.srcObject = remoteStream;
                videoEl.play();

                handleTouchStart = function(t) {
                    //t.pageX and t.pageY are x and y
                    var videoRect = videoEl.getBoundingClientRect();
                    sendMessage(
                        (t.pageX - videoRect.x) / videoRect.width,
                        (t.pageY - videoRect.y) / videoRect.height,
                        true
                    );
                };
                handleTouchEnd = function(t) {
                    var videoRect = videoEl.getBoundingClientRect();
                    sendMessage(
                        (t.pageX - videoRect.x) / videoRect.width,
                        (t.pageY - videoRect.y) / videoRect.height,
                        false
                    );
                };
            });
        });
    });
    conn.on('data', handleData);
    conn.on('error', function() {
        console.log("ERROR ERROR ERROR");
        choiceDiv.hidden = true;
        hostDiv.style.visibility = "visible";
    });

    conn.on('close', handleClose);
}
    </script>
</html>
